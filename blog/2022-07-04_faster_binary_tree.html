<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="เมื่อความแค้นและ SIMD(ซิมดี) ทำให้ Binary Tree คุณเร็วขึ้น" />
    <meta property="og:type" content="article" />
    <meta property="og:image" content="pics/tree.jpg" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bai+Jamjuree:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@500&display=swap" rel="stylesheet">
</head>
<body>

**เมื่อความแค้นและ SIMD (ซิมดี) ทำให้ Binary Tree คุณเร็วขึ้น**
2022-07-04

<img src="pics/simd_binary_tree.jpg" alt="">

หลายๆครั้งโปรแกรมเราช้าแม้ว่าเราจะใส่โครงสร้างข้อมูลสุดบรรเจิดกับอัลกอริทึมสุดล้ำลงไปแล้ว
แต่หลายๆจุดที่โปรแกรมช้ากลับเป็นอะไรง่ายๆอย่างการบวกลบคูณหาร

ถ้าเราต้องคำนวนแบบเดิมๆกับข้อมูลจำนวนเยอะๆ เทคนิคที่ชื่อ SIMD (อ่านว่าซิมดี) อาจจะทำให้โปรแกรมเราแรงขึ้นได้ถึง 4 - 16 เท่า
เป็นเทคนิคค่อนข้างมาตรฐานที่คนทำแอพพลิเคชั่น real-time เพื่อนผมทุกคนรู้จัก
เพื่อนที่ทำงานผมทุกคนพูดคำว่า SIMD บ่อยกว่าคำว่า "ข้าวผัดกะเพรา" ซะอีก

SIMD มีในแทบทุกแพลตฟอร์มที่คุณใช้ไม่ว่าคุณจะใช้ [C++](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html),
[C#](https://docs.microsoft.com/en-us/dotnet/standard/simd),
[Unreal Engine (C++)](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html),
[Unity](https://docs.unity3d.com/Packages/com.unity.burst@1.4/manual/docs/CSharpLanguageSupport_BurstIntrinsics.html),
[เขียนเว็บ](https://www.infoq.com/articles/webassembly-simd-multithreading-performance-gains/),
ฯลฯ
มีบนแทบทุกฮาร์ดแวร์ AMD Ryzen, Intel iSomething, Arm (Neon) ย้อนกลับไปถึงเครื่อง Playstation 2
และที่สำคัญโปรแกรมคุณใช้ไฟเท่าเดิมไม่ร้อนขึ้น
SIMD จึงเป็นอาวุธเทพที่คุณควรมีติดตัวไว้ไม่ว่าจะเดินทางไปแพลตฟอร์มไหนก็ตาม

เราก็มาเข้าเรื่องกันเลยดีกว่า

ความแค้นคือแรงขับเคลื่อนที่ดีที่สุด
===

![หนึ่งในสไลด์จากวิชาที่ผมลงเรียน มีคนนึงที่ชนะผมชื่อ อิมานิชิ](pics/revenge.jpg)

สำหรับพวกคุณแล้ว binary tree คืออะไร
พวกคุณอาจจะมองมันเป็นเพียง data structure เร็ว O(log(n)) ตอนเสิร์ชข้อมูลที่ไม่มีความสำคัญอะไร
สำหรับผม binary tree คือสัญลักษณ์ของความแค้น

ตอนที่ผมเรียนปริญญาโทอยู่นั้น ผมมีโอกาสเทคคอร์สที่เกี่ยวกับการเรนเดอร์ภาพเสมือนจริงด้วยคอมพิวเตอร์
เป็นคอร์สที่เราเขียนโปรแกรมทุกอย่างเอง
ในคอร์สอาจารย์เลยบอกว่าให้นักเรียนไปเขียน renderer กันมาด้วยตัวเองเป็นการบ้านย่อยอันนึง
แต่สิ่งที่ผมไม่รู้ในตอนนั้นคือ อาจารย์จะเอาประสิทธิภาพมาวัดกันด้วย
แน่นอนว่าด้วยความที่ผมเป็นเด็กดีตั้งใจทำการบ้าน
ทำให้ผมสามารถเอาชนะเด็กสามสิบกว่าคนในห้องรวมทั้งอาจารย์ผมได้อย่างไม่ยากนัก

แต่มีคนนึงที่ผมไม่สามารถชนะได้คือ อิมานิชิ

ช่วงแรกๆผมก็คิดแค่ว่ามันเป็นแค่การบ้านเพียงอันหนึ่งเท่านั้น
เราไม่ควรจะไปใส่ใจอะไรมาก
นับจากวันนั้นถึงวันนี้ก็เป็นเวลาหกปี
แม้ว่าผมกับอิมานิชิไม่รู้จักกันและไม่เคยคุยกันในชีวิตจริง
ความแค้นของผมค่อยๆเติบใหญ่
ไฟแค้นที่มีต่ออิมานิชิไม่สามารถดับลงและนับวันยิ่งแรงขึ้น

ผมเลยอยากลองเอา SIMD มาใช้ดูว่าการบ้านที่ผมทำไปแล้วยังมีส่วนที่ทำให้เร็วขึ้นได้อีก
และเผื่อคนอยากลองทำตาม ผมจะใช้โค้ดทั้งหมดจากหนังสือ [Ray Tracing The Next Week](https://raytracing.github.io/)

![รูปผลลัพธ์โปรแกรมจาก Ray Tracing The Next Week ที่เราจะมาทำให้เร็วขึ้น](pics/rt_result_before.jpg)

พาเรโต โปรไฟล์ลิ่ง (Pareto Profiling)
===

Pareto principle คือหลักการที่บอกว่าผลพวง 80% มาจากสาเหตุเพียง 20% เท่านั้น
ถ้าเรารับหลักการนี้มาใช้กับโค้ดเราก็คือเวลา 80% ของโปรแกรมเราอาจจะวนอยู่กับกับโค้ดเพียง 20% เท่านั้น
ดังนั้นขั้นแรกของการทำให้โปรแกรมของเราเร็วขึ้นคือการหาว่าอะไรคือส่วนที่ช้าของโปรแกรมเรา

แต่ถ้าคุณทำงานบริษัทใหญ่ๆโค้ดหลายล้านบรรทัดต่อโปรเจกต์
มันเลยเป็นไปไม่ได้เลยที่เราจะไปหาว่ามันช้าที่ไหนด้วยตัวเอง
เราเลยต้องพึ่ง profiler
ถ้าคุณใช้ Unity ก็ใช้ Unity profiler ถ้าคุณใช้ C++ ผมแนะนำ Intel VTune Amplifier ไม่ก็ AMD uProf ขึ้นอยู่กับว่าคุณใช้ hardware อะไร

หลังจากผมคลิกๆใน AMD uProf ผมก็ได้ต้นเหตุของความช้าออกมา

<img src="pics/pt_hotspot.jpg" alt="">

โปรแกรมใช้เวลา 54 วินาที และส่วนที่ช้าที่สุดของโปรแกรมซึ่งกินเวลาไปถึง 82% ก็ไม่พ้นฟังก์ชั่น `trace_ray`
ถ้าผมทำให้ `trace_ray` เร็วขึ้นได้สัก 4 เท่า
โปรแกรมผมก็คงจะทำงานสัก 20 วินาทีเท่านั้น
(จริงๆแล้วมันก็ไม่ได้เป็น 80% เสมอไป ผมได้ 80% เพราะผมฟลุ้กเฉยๆ)

!!!
    #บ่น

    จริงๆแล้วจะมีคำอีกคำที่ได้ยินบ่อยๆคือ "Death by a thousand cuts" ตายด้วยแผลหนึ่งพันแห่ง
    คือการที่คุณไม่เข้าใจว่าโค้ดที่คุณเขียนมันช้าหรือเร็ว แล้วคุณก็เขียนโค้ดช้าๆทิ้งไว้เต็มไปหมด
    กรณีนี้พาเรโตก็อาจจะช่วยคุณไม่ได้

    ถ้าคุณอยากรู้ว่าแผลพวกนี้หน้าตายังไงผมแนะนำให้ดูนี่หลังอ่านบทความจบ
    [SIMD at Insomniac Games](https://www.gdcvault.com/play/1022248/SIMD-at-Insomniac-Games-How)

การตามรอยรังสี (ray tracing) ด้วยต้นไม้ทวิภาค (binary tree)
===

`trace_ray` หรือฟังก์ชั่นทำ ray tracing คือตัวการแห่งความช้า
ถ้าเราอยากทำให้สิ่งหนึ่งเร็วเราควรจะเข้าใจว่าสิ่งนี้ทำอะไร
และผมคิดว่าคุณจะอินได้มากกว่านี้ถ้าคุณเข้าใจว่า ray tracing คืออะไรแล้วมันไปเกี่ยวอะไรกับ binary tree

ray คือรังสี
ซึ่งในที่นี้คือรังสีในมุมมองของคณิตศาสตร์ซึ่งเราเรียนกันไปสมัยประถมในบทที่ชื่อว่า "จุด เส้นตรง รังสี และส่วนของเส้นตรง"
ดังนั้นกระบวนการ ray tracing คือการที่เรายิงรังสีออกไปแล้วถามว่ามันไปชนกับอะไรในฉากสามมิติของเรา

ในการเรนเดอร์ภาพสมจริง สิ่งหนึ่งที่สำคัญมากคือการทดสอบว่า จุดสองจุดในฉากสามารถมองเห็นซึ่งกันและกันได้มั้ย
อย่างเช่น ถ้าคุณอยากรู้ว่าพื้นตรงนี้มีเงามั้ยคุณก็ต้องทดสอบว่าระหว่างจุดบนพื้นที่คุณมองอยู่กับแหล่งกำเนิดแสงว่ามีอะไรขวางมั้ย
คุณสามารถทำได้ด้วยการยิงรังสีเริ่มจากพื้นไปแหล่งกำเนิดแสง ถ้ารังสีชนบางสิ่งก่อนไปถึงแหล่งกำเนิดแสงก็แปลว่าพื้นตรงนั้นมีเงา

![ถ้ารังสีจากพื้นพุ่งไปชนแหล่งกำเนิดแสงโดยที่ไม่มีอะไรขวาง<br>ก็แปลว่าพื้นตรงนี้ได้รับแสงเต็มๆและไม่มีเงา](pics/unshadowed.jpg width=250) ![ถ้ารังสีจากพื้นไปพุ่งไปแล้วมีอะไรขวางไว้ก็แปลว่าตรงนี้มีเงา](pics/shadowed.jpg width=250)

เนื่องจากฉากสามมิติของเราก็จะประกอบไปด้วยของจำนวนมหาศาล
โค้ด ray tracing แบบง่ายสุดคุณก็จะต้องไปเช็ครังสีของคุณกับของทุกๆชิ้นแบบถึกๆ
ว่ารังสีของเราไปโดนของชิ้นไหนมั้ย

![ถึกเช็คกับทรงกลมอันแรก วืด~](pics/rt_naive_step1.jpg) ![ถึกเช็คกับทรงกลมอันที่สอง วืด~](pics/rt_naive_step2.jpg) ![ถึกเช็คกับทรงกลมอันที่สาม ชน!](pics/rt_naive_step3.jpg)

แต่ในชีวิตจริงฉากที่เราใช้เรนเดอร์หนังมีอาจจะมีของจำนวนหลายหมื่นล้านหรือแสนล้านชิ้น
ดังนั้นเราควรจะใช้วิธีที่ฉลาดกว่าเช็คของทุกชิ้นแบบถึกๆ
ตรงนี้เองที่เราสามารถใช้ binary tree เข้าช่วย
โดยที่ในแต่ละ node ของต้นไม้จะมีกล่องครอบของฝั่งซ้ายกับของฝั่งขวาไว้
ถ้ารังสีของเราไม่ชนกล่องไหนก็แปลว่า
เราสามารถข้ามการเช็คกับของในกล่องนั้นทั้งกล่องไปได้เลย


![รังสีชนตัดกับกล่องฝั่งขวาเพียงด้านเดียว ข้ามไม่ต้องเช็คของฝั่งซ้าย 4 ชิ้น](pics/rt_smart_step1.jpg)
![รังสีชนตัดกับกล่องฝั่งขวาเพียงด้านเดียว ข้ามไม่ต้องเช็คของฝั่งซ้าย 2 ชิ้น](pics/rt_smart_step2.jpg)
![รังสีเราตัดกับกล่องฝั่งซ้ายเพียงด้านเดียว ข้ามไม่ต้องเช็คของฝั่งขวา 1 ชิ้น](pics/rt_smart_step3.jpg)
![ถึกเช็คกับทรงกลมในกล่อง ชน!](pics/rt_smart_step4.jpg)

แทนที่เราจะเช็คของ 8 ชิ้น
การใช้ binary tree เข้าช่วย ทำให้เราเช็คกล่องเพียง 3 กล่องและของ 1 ชิ้น

!!!
    #บ่น

    สิ่งที่คนส่วนใหญ่เข้าใจ ray tracing ผิด

    - ผมเคยต้องเถียงกับคนที่เข้าใจผิดที่ว่า ray tracing คือการยิงคลื่นรังสีแม่เหล็กไฟฟ้า
    - ผมมักจะได้อ่านบทความหรือได้ดูวิดีโอยูทูบค่อนข้างบ่อยที่คิดว่า ray tracing == การทำให้ภาพสมจริง ซึ่งมันไม่เกี่ยวกัน คุณใช้ ray tracing ทำฟิสิกส์ก็ได้ หรือ raycast ใน Unity ก็คือ ray tracing แบบนึง
    - เพื่อนผมเคยบอกว่าเกมนี้ใช้ ray tracing "เทียม" ทุกวันนี้ผมก็ยังไม่รู้ว่าอะไรคือ ray tracing เทียม
    - บางคนเข้าใจผิดหนักที่สุดคือ ray tracing จะทำได้ต้องมีการ์ดจอ RTX เท่านั้น ซึ่งจริงๆแล้ว ray tracing มันเป็นแค่โปรแกรม แค่คุณมีคอมพิวเตอร์คุณก็ทำ ray tracing ได้แล้ว และไม่ต้องมี binary tree ด้วยซ้ำ

อะไรใน ray tracing ที่ช้า
===

<img src="pics/pt_hotspot.jpg" alt="">

ถ้าเรากลับไปดูที่ AMD uProf ของเราแล้วคลิกเข้าไปดูในฟังก์ชั่น `trace_ray` ก็จะพบว่า

<img src="pics/pt_hotspot2.jpg" alt="">

โปรแกรมไปหนักในฟังก์ชั่น hit ซึ่งคำนวนว่ารังสีตัดกับกล่องมั้ย
และทุกบรรทัดก็จะเห็นได้ว่าการคำนวนไม่ได้ใช้ท่ายากอะไร มีแค่ ลบ หาร min max
การจะทำฟังก์ชั่นนี้ให้เร็วขึ้นมีแค่วิธีเดียวเท่านั้นคือ เราต้องทำให้คอมเรา ลบ หาร min max ให้เร็วขึ้น

!!!
    #บ่น

    นี่เป็นครั้งแรกที่ผมลองวัดประสิทธิภาพโปรแกรมบน CPU ตระกูล AMD
    การใช้ AMD uProf ทำให้ผมรู้สึกหงุดหงิดอย่างบอกไม่ถูก หลายเมนูที่โฆษณาไว้ผมก็หาไม่เจอ
    มันทำให้ผมค้นพบว่าผมคิดถึง Intel VTune Profiler
    คอมเครื่องหน้าผมคงจะเก็บตังซื้อ Intel แทน

SIMD (Single Instruction Multiple Data)
===

โค้ดของคุณเมื่อถูก build ก็จะกลายเป็นคำสั่ง (instruction) หลายๆคำสั่งต่อกัน
บวกเลขสองตัวก็นับเป็นหนึ่งคำสั่ง
คูณเลขสองตัวก็นับเป็นอีกหนึ่งคำสั่ง
เวลาทำงานคอมพิวเตอร์จะกินชุดคำสั่งทีละหนึ่งคำสั่งเท่านั้น
มันทำให้เราสามารถบวกเลขทีละตัว
และคูณเลขทีละตัวได้

แต่การบวกลบคูณหารเลขแค่ทีละ 1 ตัวมันไม่เร้าใจ

SIMD หรือ Single Instruction Multiple Data (1 คำสั่ง หลายข้อมูล)
จะทำให้คุณสามารถบวกลบคูณหารเลขได้พร้อมๆกันหลายตัวได้ในหนึ่งคำสั่ง
แล้ว SIMD หน้าตายังไง
ลองดูตัวอย่างต่อไปนี้ที่เราจะทำการคำนวนเลขทีละ 4 ตัว

เขียน Code ปกติ  | เขียนด้วย SIMD
----------|-----------
assign ค่าแบบตัวต่อตัว<br>`a[0] = x;`<br> `a[1] = y;`<br> `a[2] = z;`<br> `a[3] = w;` | `__m128 a = _mm_set_ps(x, y, z, w);`
broadcast ค่า<br>`a[0] = x;`<br> `a[1] = x;`<br> `a[2] = x;`<br> `a[3] = x;` | `__m128 a = _mm_set1_ps(x);`
บวก<br>`c[0] = a[0] + b[0];`<br> `c[1] = a[1] + b[1];`<br> `c[2] = a[2] + b[2];`<br> `c[3] = a[3] + b[3];` | `__m128 c = _mm_add_ps(a, b)`
คูณ<br>`c[0] = a[0] * b[0];`<br> `c[1] = a[1] * b[1];`<br> `c[2] = a[2] * b[2];`<br> `c[3] = a[3] * b[3];` | `__m128 c = _mm_mul_ps(a, b)`
min<br>`c[0] = min(a[0], b[0]);`<br> `c[1] = min(a[1], b[1]);`<br> `c[2] = min(a[2], b[2]);`<br> `c[3] = min(a[3], b[3]);` | `__m128 c = _mm_min_ps(a, b)`

SIMD จะทำให้เราสามารถปู้ยี่ปู้ยำเลขได้ทีละ 4 ตัว
แต่ค่าใช้จ่ายในการใช้พลัง SIMD ก็คือการที่โค้ดคุณเริ่มอ่านไม่รู้เรื่อง
ดังนั้นคุณควรจะใช้ SIMD ตอนที่โปรแกรมคุณเริ่มนิ่งและไม่ค่อยเปลี่ยนแล้ว

!!!
    #บ่นและเพิ่มเติม

    ถ้าคุณไม่เคยใช้ SIMD มาก่อน คุณจะโคตร pain เพราะไม่รู้ว่าฟังก์ชั่นที่คุณต้องใช้มันชื่ออะไร
    ถ้าคุณหาฟังก์ชั่นอะไรไม่เจอผมแนะนำให้หาใน [Intel's intrinsic guide](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html)
    ซึ่งคนใช้ AMD ก็ใช้ได้

    หลังจากคุณใช้ SIMD จนชำนาญ คุณก็จะยังหาไม่เจอ
    เพราะใครจะไปจำชื่อฟังก์ชั่นได้ แต่จะรู้สึกทนกับ pain จากการหาไม่เจอได้ดีขึ้น

    ตัวอย่างที่ผมโชว์ไปคือชุดคำสั่ง SIMD ที่เรียกว่า SSE มันทำให้บวกลบเลขได้ทีละ 4 ตัว
    ถ้าคุณลองหาชุดคำสั่ง AVX, AVX2, ... มาใช้ก็จะทำให้บวกลบเลขทีละหลายตัวมากขึ้นอีก

Gotta Go Fast
===

ใน binary tree แต่ละ node เราจะเรียกฟังก์ชั่นเช็ครังสีตัดกล่องสองที รอบแรกเช็คกับกล่องด้านซ้าย และรอบสองเช็คกับกล่องด้านขวา
แต่ใน SIMD เรารู้ว่าเราสามารถคำนวนเลขได้ทีละ 4 ตัว
ถ้าเราอยากใช้ SIMD วิธีที่ชัดเจนวิธีนึงเลยคือ แทนที่ฟังก์ชั่นของเราจะเช็ครังสีตัดทีละกล่อง เราก็แก้ให้ฟังก์ชั่นเช็ครังสีตัดกล่องทีละ 4 กล่องพร้อมกัน

เพื่อให้แต่ละ node มีกล่อง 4 ใบแทน 2 ใบผมต้องแปลงจาก binary tree (2 ลูกต่อ node) เป็น quadtree (4 ลูกต่อ node)
สิ่งที่เราต้องทำคือการพัง binary ลงมาแบบชั้นเว้นชั้น
ชั้นที่ไม่ถูกเว้นให้ทุกๆ node ในชั้นนั้นเอาหลานของตัวเองมาเป็นลูก

![ก่อนพังชั้นเว้นชั้น](pics/before_skip.jpg width=100) ![หลังพังชั้นเว้นชั้น](pics/after_skip.jpg width=100)

คราวนี้เมื่อแต่ละ node มีกล่อง 4 ใบแล้วเราต้องทำการแปลงโค้ดจากที่เช็คทีละกล่องเป็นเช็คทีละ 4 กล่องแทน
ซึ่งโค้ดเช็คทีละกล่องหน้าตาแบบนี้
~~~c++
    float hit(const ray& r, float t_min, float t_max) const
    {
        for (int a = 0; a < 3; a++)
        {
            float o = r.origin[a];
            float d = 1.0f / r.direction[a];
            float t_near = (this->minimum[a] - o) * d;
            float t_far  = (this->maximum[a] - o) * d;
            t_min = max(min(t_near, t_far), t_min);
            t_max = min(max(t_near, t_far), t_max);
        }
        return t_max <= t_min;
    }
~~~

แล้วผมแปลงแบบตรงไปตรงมาสุดๆ แบบบรรทัดต่อบรรทัด
จะเห็นได้ว่าจริงๆแล้วการแปลงโค้ดก็ไม่ได้ยากอะไร ไปยากตอนหาว่าฟังก์ชั่น SIMD ที่ต้องใช้ชื่ออะไรซะมากกว่า

~~~c++
    __m128 hit4(const ray& r, float _t_min, float _t_max) const
    {
        __m128 t_min = _mm_set1_ps(_t_min);
        __m128 t_max = _mm_set1_ps(_t_max);

        for (size_t a = 0; a < 3; a++)
        {
            __m128 o = _mm_set1_ps(r.origin[a]);                             // float o = r.origin[a];
            __m128 d = _mm_set1_ps(1.0f / r.direction[a]);                   // float d = 1.0f / r.direction[a];
            __m128 t_near = _mm_mul_ps(_mm_sub_ps(this->minimum4[a], o), d); // float t_near = (this->minimum[a] - o) * d;
            __m128 t_far = _mm_mul_ps(_mm_sub_ps(this->maximum4[a], o), d);  // float t_far  = (this->maximum[a] - o) * d;
            t_min = _mm_max_ps(_mm_min_ps(t_near, t_far), t_min);            // t_min = max(min(t_near, t_far), t_min);
            t_max = _mm_min_ps(_mm_max_ps(t_near, t_far), t_max);            // t_max = min(max(t_near, t_far), t_max);
        }
        return _mm_cmpngt_ps(t_min, t_max);                                  // return t_max <= t_min;
        // cmpngt = compare not greater than
    }
~~~
ซึ่ง hit4 จะ return ค่าเป็นผลลัพธ์การเช็คว่ารังสีตัดกล่องทั้งสี่กล่องในตัวแปร `__m128` ซึ่งวิธีเอาค่าออกมาเป็น bool 4 ตัว ก็เพียงแค่หาฟังก์ชั่น SIMD ที่ถูกต้องมาใช้

ผลลัพธ์
===

<img src="pics/faster.jpg" alt="">

ในโปรแกรมหลายพันบรรทัดนี้
ผมแก้โค้ดไปทั้งสิ้นประมาณ 100 กว่าบรรทัด
แต่โปรแกรมเร็วขึ้นจาก 54 วินาทีเป็น 11 วินาที หรือคือประมาณ 4 เท่ากว่าๆ
โดยที่การทำงานยังเหมือนเดิมทุกอย่าง

และที่สำคัญกว่านั้นคือ
คุณต้องเช็คด้วยว่าหลังคุณแก้โค้ดแล้วมันยังทำงานเหมือนเดิมมั้ย
เพราะผมเคยแก้แล้วโปรแกรมเร็วขึ้นร้อยเท่าแต่ผลลัพธ์เป็นภาพดำๆมืดมิด

![ก่อนการแก้](pics/rt_result_before.jpg) ![หลังการแก้](pics/rt_result_after.jpg)

สามารถลองเอาไปรันด้วยตัวเองได้ที่นี่ [raytracing.github.io/downstairs_optimization](https://github.com/the-programmer-downstairs/raytracing.github.io/blob/downstairs_optimization/src)
และโค้ดที่ถูกแก้ทั้งหมดอยู่ไฟล์นี้ [bvh.h](https://github.com/the-programmer-downstairs/raytracing.github.io/blob/downstairs_optimization/src/TheNextWeek/bvh.h)

!!!
    #บ่น (จากประสบการณ์ชีวิตจริง)

    จริงๆแล้วเราควรจะวัดประสิทธิภาพบ่อยกว่านี้มาก
    เช่น ถ้าคุณคลั่งไคล้ refactor เป็น OOP มาก แต่ไม่เข้าใจว่า virtual function มีผลอะไรกับโค้ดบ้างและทำให้อะไรช้าลงบ้าง
    หรือถ้าคุณชอบแตกฟังก์ชั่นใหญ่ๆออกเป็นฟังก์ชั่นเล็กๆแต่ไม่รู้ว่า inline คืออะไร และคอมไพเลอร์ทำให้เรามั้ย
    คุณก็ควรจะวัดประสิทธิภาพก่อนและหลัง refactor โค้ดเพื่อให้มั่นใจว่ามันไม่ช้าลง

สรุป
===

SIMD เป็นเครื่องมือที่ผมเห็นครั้งแรกตอนปริญญาตรี
ผมไม่ค่อยเชื่อว่ามันจะมีประโยชน์
เพราะมันดูค่อนข้างเฉพาะเจาะจงกับงาน
แต่จริงๆแล้วถ้าอยากใช้ SIMD กับงานอะไร
ก็เพียงแค่ต้องจับให้ได้ว่า เราจะทำอะไรทีละ 4 อย่างพร้อมกัน
ซึ่ง SIMD นี้เองก็เป็นเครื่องมือที่ผมใช้ทำให้ระบบเซฟรูปของเกมเร็วขึ้น 2 - 3 เท่า

จะเห็นได้ว่าการที่ผมทำให้ ray tracing เร็วขึ้นได้ก็ต้องใช้ความเข้าใจเข้าช่วยส่วนหนึ่ง
ดังนั้นผมคิดเสมอว่าคนที่ optimize ได้ดีที่สุดคือคนที่เข้าใจการทำงานในส่วนนั้นๆ
การทำให้โค้ดเร็วขึ้นควรจะเป็นหน้าที่ของทุกๆคน
ถ้าทีมคุณคิดจะฝากประสิทธิภาพของทั้งโปรแกรมไว้กับคนเพียงคนเดียว
คุณอาจจะต้องลองคิดดูใหม่

!!!
    #บ่น

    ในหลายๆเคสที่คุณใช้ SIMD จนชำนาญแล้ว
    คุณอาจจะสังเกตว่า SIMD ก็ไม่ได้ช่วยให้โปรแกรมเร็วขึ้น
    นั่นแปลว่าคุณอาจจะไปติดปัญหาข้อมูลเข้ามาไม่ทัน หรือที่เรียกว่า latency bound แทน
    ซึ่งพอผมลองเขียนอธิบายผมก็ค้นพบว่าบทความมันเริ่มจะยาวเกินไป และของที่ย่อยยากอยู่แล้วก็อาจจะย่อยไม่ได้เลยแทน

    และต่อให้เราไม่พูดถึง latency การใช้ SIMD ก็ยังมีข้อควรระวังและคำแนะนำในการใช้ที่ควรรู้ (เช่น ทำไมคุณต้องเลี่ยง code dependency)
    แต่ผมอยากให้บล็อกนี้เป็นแค่แรงบันดาลใจ
    ที่เหลือพวกคุณก็คงหาอ่านต่อเองได้ไม่ยาก
    เช่น http://www.cs.uu.nl/docs/vakken/mov/ ก็เป็นจุดเริ่มต้นที่ดี

ถามว่ายังแค้นอะไรอยู่มั้ย
กว่าจะเขียนบทความมาถึงนี่ก็ใช้เวลาหลายวันอยู่
ต้นไม้ทวิภาคผมก็ไม่เป็นต้นไม้ทวิภาคไม่ตรงกับชื่อบทความอีกต่อไป
แล้วผมก็เริ่มลืมๆอิมานิชิไปแล้วว่าเค้าคือใคร

<!--
Cache
===

โปรแกรมที่รันบน CPU หรือ GPU ส่วนใหญ่ในปัจจุบัน**ไม่ได้**ติดปัญหาที่คำนวนเร็วไม่พอ (compute-bound) แต่ติดปัญหาที่ข้อมูลเข้ามาเร็วไม่พอ (latency-bound)
เรียกง่ายคือ CPU คุณว่างงานค่อนข้างบ่อยเพราะต้องรอข้อมูลเข้ามาให้คำนวน

CPU Core ของคุณทำงานเป็นรอบ (cycle)
แต่ละรอบก็จะทีละหนึ่งคำสั่ง
เช่น
หนึ่งรอบก็ทำบวกเลขก็หนึ่งคำสั่ง
อีกหนึ่งรอบก็ทำคูณเลขอีกหนึ่งคำสั่ง
คอมพิวเตอร์คุณคิดเลขได้แสนล้านคำสั่งต่อหนึ่งวินาที
ดังนั้นจริงๆแล้วคอมพิวเตอร์คุณคิดเลขเร็วพอสมควร

แต่ถ้าตัวเลขที่คุณต้องการเอามาคูณกันหรือเอามาบวกกันไม่ได้อยู่ในทดไว้ในความจำ CPU Core
แต่ต้องไปขอข้อมูลมากจาก RAM
คุณจะต้องติดโทษรอข้อมูลไปถึงสองร้อยรอบ
แทนที่จะเอาเวลานั้นไปทำอย่างอื่นได้เช่นคูณเลขสองร้อยตัว
ต้องมานั่งตากลมรอข้อมูลเข้าแทน
การรอนี้เองที่เรียกว่า latency

ตัวช่วยลด latency ก็คือสิ่งที่เรียกว่า Cache ซึ่งมีสามระดับเรียก L1 และ L2 และ L3
โดย L1 ขนาดเล็กสุดแต่เร็วแท้ L2 ขนาดใหญ่ขึ้นมาแต่ช้าลง L3 ใหญ่ขึ้นมาอีกและช้าลงอีก

ปกติเวลา CPU Core ทำงานมันจะทำงานกับข้อมูลทดไว้ที่หน่วยจำของมันเรียก register

- ถ้าข้อมูลคุณไม่อยู่ที่ register ก็จะไปขอข้อมูลที่ L1 รอไป 5 - 10 รอบ
- ถ้าไม่อยู่ที่ L1 ก็จะไปขอที่ L2 รอไปประมาณ 10 - 20 รอบ พร้อมกับเอาข้อมูลมาเก็บที่ L1
- ไม่อยู่ที่ L2 ก็จะไปขอที่ L3 รอไปประมาณ 40 - 50 รอบ พร้อมกับเอาข้อมูลมาเก็บที่ L2
- ไม่อยู่ที่ L3 ก็จะไปขอที่ RAM ซึ่ง RAM มีเกือบแน่นอนแต่ก็ต้องรอไปหลายร้อยรอบ พร้อมกับเอาข้อมูลมาเก็บที่ RAM

ในความคิดของโปรแกรมเมอร์ทั่วๆไปก็จะมองว่า
Cache เป็นเพียงแค่ตัวช่วยที่ทำงานให้โปรแกรมคุณเร็วขึ้น
แต่ถ้าคุณอยากเขียนโปรแกรมให้เร็วคุณต้องเปลี่ยน mindset นิดนึง
ให้มองว่าคุณพยายามเขียนโปรแกรมลง Cache L1 แทน
ถ้าไม่ไหวจริงๆก็ยอมล้นไป L2 และ L3 ตามลำดับ

!!!
    #เพิ่มเติมและบ่น

    เหตุผลที่ Cache มีหลายระดับก็เพราะ Cache แต่ละระดับถูกออกแบบมาไม่เหมือนกัน
    เช่น L1 ถูกออกแบบมาด้วยเทคนิคพิเศษที่ทำให้สามารถทำงานได้เร็วจี๋
    แต่เทคนิคนี้เองไม่สามารถใช้ได้ถ้าเราขยายขนาด L1 ให้ใหญ่ขึ้นเกินไป

    แล้วการมี Cache หลายระดับเลยยังเป็นเรื่องที่เลี่ยงไม่ได้
    และมันก็เป็นเรื่องที่เลี่ยงไม่ได้มา 60 ปีแล้ว
    ถ้าคุณไม่เข้าใจ latency จะเป็นศัตรูที่ชกใต้เข็มขัดคุณรัวๆโดนที่คุณไม่รู้ว่าทำไมโปรแกรมคุณช้า

    (สำหรับคนที่รู้อยู่แล้ว)
    ผมทราบดีครับว่าข้ามเรื่อง Superscalar, Virtual Address, TLB, และ Cache Policy ไป
    แต่ขออนุญาตข้ามไปก่อนครับ

Search and Replace Operation
===

พอเรารู้ว่า Cache มีขนาดเล็กเช่น L1 บน CPU รุ่นใหม่ๆ ไม่ 256KB ก็ 512KB เท่านั้น
มีสิ่งนึงเลยที่เราทำได้ทันทีคือการลดขนาดประเภทตัวแปรที่เราใช้
โดยในโค้ด [Ray Tracing The Next Week](https://raytracing.github.io/) ที่ผมโหลดมานั้น
สิ่งนึงเลยที่ผมสังเกตเห็นเป็นอย่างแรกคือโด้ดถูกเขียนด้วยตัวแปรประเภท double ทั้งโปรแกรม

double นั้นใช้พื้นที่ 8B แต่ float ใช้แค่ครึ่งเดียวคือ 4B
ถ้าเราเปลี่ยนจาก double เป็น float ก็แปลว่าจำนวนตัวแปรที่จะเข้าไปอยู่ L1 ได้จะมีจำนวนมากขึ้น
ผมเลยเปิด visual studio แล้วก็แทนคำว่า double ทั้งหมดด้วยคำว่า float
ใช้เวลาทั้งสิ้น 1 นาที

และด้วยเวลาเพียง 1 นาทีเท่านั้น โปรแกรมผมก็เร็วขึ้น 20%

!!!
    #เพิ่มเติม

    CPU อย่าง AMD Zen 2 สามารถทำบวกลบคูณ float กับ double ได้เร็วเท่ากัน
    แต่จะทำการหาร double ได้ช้ากว่า float
    ดังนั้นจริงแล้ว 20% ทีเร็วขึ้นก็มีมาจากการที่เราหารเลขเร็วขึ้นหน่อยนึง


Death By a Thousand Cuts (ตายด้วยแผลหนึ่งพันแห่ง)
===

โค้ดของคุณเมื่อถูก compile build ก็จะกลายเป็นคำสั่ง (instruction) หลายๆคำสั่งต่อกัน
ถ้าคุณเอาเลขมาบวกกันสองตัวก็นับเป็นหนึ่งคำสั่ง
ถ้าคุณเอาเลขสองตัวมาเทียบกันก็นับเป็นอีกหนึ่งคำสั่ง
แต่สิ่งสำคัญที่คุณควรจะรู้คือ แต่ละคำสั่งใช้เวลาไม่เท่ากัน
เช่น บน Xbox หรือ PS5 ที่ใช้ CPU AMD Zen 2 กว่าคุณจะได้ผลลัพธ์การหารเลขทศนิยม คุณต้องรอนานกว่าผลลัพธ์การคูณถึงสี่เท่า
https://www.agner.org/optimize/instruction_tables.pdf

สมมติว่าคุณต้องการหารเลขทศนิยมทั้ง array ด้วยค่านึงที่ผู้ใช้ใส่เข้ามา
สมมติว่าผู้ใช้ใส่ 5 เข้ามา แทนที่คุณจะหารซึ่งใช้เวลานาน คุณก็ไปคิดส่วนกลับ (reciprocal) มาล่วงหน้าได้ 0.2
แล้วก็เอาส่วนกลับไปคูณทั้ง array แทน

-->
## Acknowledgement

ขอขอบคุณ Nontawat Charoenphakdee, Takkasila Saichol, Paisan Ingkavara, Thanik Sitthichoksakulchai, Vidvas Keawcharoen สำหรับการ proofread และ feedback ครับ
และภาพจาก irasutoya โดย Mifune Takashi (みふねたかし)

<iframe class="fbbanner" src="https://www.facebook.com/plugins/page.php?href=https%3A%2F%2Fwww.facebook.com%2Fa.programmer.downstairs/%2F&tabs&width=340&height=130&small_header=false&adapt_container_width=true&hide_cover=false&show_facepile=true&appId=621489091282986" width="340" height="130" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowfullscreen="true" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share"></iframe>

</body>
<link rel="stylesheet" href="blog.css">
<script> window.markdeepOptions = {tocStyle: 'short'}; </script>
<script src="js/markdeep.min.js?"></script>
<!-- <script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script> -->
</html>